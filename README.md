# Pitch-axis stabilizer for airplane :airplane:
This arduino sketch is a servo controller that stabilizes the pitch-axis of a radio-controlled airplane. It's intended to be used on tail-less aircraft to enhance their otherwise marginal stability. Nonetheless, the controller can work on machines with a large degree of passive stability. It can increase the effective static margin and allows the center of mass to be shifted aft. If tuned correctly, this can potentially increase the lift-to-drag ratio of the aircraft.  

## State measurement
Pitch stabilization can be accomplished in variety of ways. These include directly measuring the relative airflow across the aircraft, or measuring changes in the motion and inferring the state of the airflow. 

__Angle of attack sensor__:
The attitude of an airplane is mainly determined by the aerodynamic forces acting upon it. For the pitch axis, the torque generated by these forces is primarily a function of the angle of attack. If one can measure this state, one can apply corrective actions that rotate the aircraft towards a particular angle. Therefore, we can gauge the stability of the aircraft based on how quickly it coverges towards said angle (or coversely its instability if it diverges).    

The simplest angle-of-attack sensor is a [low-friction potentiometer attached to a weathervane](https://www.ilmailu.org/forum/index.php?action=dlattach;topic=5147.0;attach=10336). As the weathervane will closely follow the local airflow, the deflection of the weathervane relative to some reference angle becomes proportional to the angle of attack.

__Inertial measurement unit (IMU)__: 
One can maintain the attitude of the aircraft by measuring its change in orientation and providing an appropriate correction. In this case, we use the angular velocity of a gyroscope as the proportional term in a PID controller. The integral term becomes the angular deflection and is approximately equal to the angle of attack for small external disturbances. Therefore, we can approximate the behaviour obtained wih an angle of attack sensor without having to use an external weathervane.  

## Control mechanisms
Indifferent of the way the aircraft's state is measured, its still nessesary to actuate some mechanisms to physically rotate the vehicle. The program considers the following designs:

__Trailing edge flaps__: This is the most common way to control a tail-less airplane. 
The program is designed to receive 2 PWM inputs from an RC receiver and generates 2 PWM outputs for servos for elevon mixing, or a single servo for a pitch actuator. When using two servos, it is assumed the aircraft is controlled by two elevons. It was written for an Arduino Nano but it should be compatible with other boards. 

__Weight shift__: It is also possible to influence the pitch axis by moving the lift vector relative to the center of mass. This comes from the very definition of torque: 

$$ T = F \cross d $$

Rather than changing the force $$ F $$ at a known distance $$ d $$ (as with trailing edge flaps), we change the distance $$ d $$ in accord to a known force. In level flight, the net force upon the aircraft is mainly the lift and this must nessecerily counter weight: 

$$ F = L = mg $$
 
Therefore, the effectiveness of this control mechanism is proportional to the magnitude of the lift vector. If the lift is large, small deflections are required. However, as the lift becomes small, the deflections become very large. Ultimately the relationship breaks down with zero lift as there is no force to generate a torque. Despite this flaw, weight shift is a valid control mechanism so long as the airplane's wing remains _loaded_.   
  
## Schematics
Since there are a few variants of the controller depending the stabilization method, there are different schematics as well. 

__Nano:__ There are two version of the sketch for the arduino nano. Despite this, it should be compatible with similar boards. Each version uses the stabilization concepts discussed above. 

- Angle of attack sensor: This schematic assumes a potentiometer is used as the sensor, but any analog sensor will work. A hall sensor is a low-friction alternative of the potentiometer.

<p align="center"> 
<img src = "/images/diagrams/nano/aoa-sensor/schematic-nano.png" width = "80%" height = "80%">
</p>

- IMU sensor: The code is designed around an MPU6050, but the general structure will work for any IMU.
<p align="center"> 
<img src = "/images/diagrams/nano/imu/schematic-imu.png" width = "80%" height = "80%">
</p>

__DigiSpark ATTiny85__: The version of the sketch does not have the option for an IMU. Rather, it serves as a lighter alternative of the Nano version for an angle of attack sensor. 
<p align="center"> 
<img src = "/images/diagrams/attiny/schematic-attiny.png" width = "80%" height = "80%">
</p>

## Dependencies
The IMU version of the sketch requires the following libraries to compile:

- [basicMPU6050](https://github.com/RCmags/basicMPU6050)
- [imuFilter](https://github.com/RCmags/imuFilter)

## References
See these pages for previous projects that inspired this work:

- [Actively stabilized pitch axis](http://www.charlesriverrc.org/articles/asfwpp/lelke_activepitch.htm)
- [Actively stabilized glider](https://www.youtube.com/watch?v=JfKrUbJYk74)

## Examples
Here is the original airplane the code was writen for:

<p align="center">
<img src = "/images/example/top_view_res.jpg" width = "30%" height = "30%">
<img src = "/images/example/front_view_res.jpg" width = "30%" height = "30%"> 
<img src = "/images/example/side_view_res.jpg" width = "30%" height = "30%">
</p>
